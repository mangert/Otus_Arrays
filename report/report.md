# Отчет о выполнении домашнего задания

### Задание 1. Динамические массивы
1. Реализованы классы (шаблонные):
- **SingleArray** - [`SingleArray.h`](../headers/SingleArray.h) (увеличивает емкость массива на 1 элемент при исчерпании емкости)
- **FactorArray** - [`FactorArray.h`](../headers/FactorArray.h) (увеличивает емкость массива на множитель при исчерпании емкости)
- **VectorArray** - [`VectorArray.h`](../headers/VectorArray.h) (увеличивает емкость массива на заданное количество элементов при исчерпании емкости)
##### Примечание: вышеперечисленные классы наследуются от базового класса Array - [`Array.h)`](../headers/Array.h) с постоянным размером
2. Реализован шаблонный класс MatrixАrray - [`MatrixArray.h`](../headers/MatrixArray.h) (хранит данные в строках). При реализации использовался шаблонный класс Array из этого задания (композиция)
3. Реализован шаблонный класс списка (для задания 2) [`List.h`](../headers/List.h) 

##### Общее примечание: методы вставки во всех классах названы push (версии push_back, push_front, push), удаления - del.


### Задание 2. Анализ производительности структур данных

**Шаблонный класс для тестов**: [`class TestArrays`](../headers/TestArrays.h)
#### Консольный вывод результатов тестирования [`test_output.txt`](test_output.txt)

## Сводная таблица результатов (время в микросекундах)

| Операция / Структура | SingleArray | VectorArray | FactorArray | List | MatrixArray |
|---------------------|-------------|-------------|-------------|------|-------------|
| **Push Back 1M** | 2,419,888,517 | 246,824,419 | 21,008 | 185,430 | 19,406,425 |
| **Random Access** | ~0 | ~0 | ~0 | ~26,508 | ~0 |
| **Random Delete** | ~2,527 | ~2,458 | ~2,595 | ~26,452 | ~38,094 |
| **Random Insert** | ~2,556 | ~2,454 | ~2,762 | ~26,739 | ~39,947 |
| **Memory Usage** | 100% | 99% | 52% | 100% | 99% |

## Детальный анализ

### 1. **Push Back Производительность**

**Рейтинг скорости (1M элементов):**

1. **FactorArray** - 21,008 μs
2. **List** - 185,430 μs
3. **MatrixArray** - 19,406,425 μs
4. **VectorArray** - 246,824,419 μs
5. **SingleArray** - 2,419,888,517 μs (40+ минут!)

## **Выводы:**

- **FactorArray** быстрее List благодаря:
  - Меньшему количеству аллокаций памяти (O(log n) vs O(n))
  - Отсутствию накладных расходов на указатели в узлах
  - Локальности данных (cache-friendly)

- **List** медленнее из-за:
  - Постоянных аллокаций памяти для каждого элемента 
  - Плохой локальности данных (память разбросана)
##### (примечание: в данной реализации в листе хранится кроме "головы" еще и "хвост", что позволяет избежать прохода по всему списку при добавлении элемента в конец)
	
- **MatrixArray** показывает средние результаты благодаря:
  - Блочному выделению памяти (целыми строками)
  - Но проигрывает FactorArray из-за избыточных копирований при resize
	
- **SingleArray** катастрофически медленный из-за O(n²) сложности

### 2. **Произвольный доступ (Random Access)**

**Рейтинг:**
1. **Все массивы** - ~0 μs (O(1) доступ)
2. **List** - ~26,508 μs (O(n) доступ)

**Выводы:**
- Массивы обеспечивают мгновенный доступ по индексу
- List требует последовательного обхода для доступа к элементу

### 3. **Вставка и удаление в середину**

**Рейтинг (среднее время):**
1. **SingleArray** - ~2,500 μs
2. **VectorArray** - ~2,450 μs  
3. **FactorArray** - ~2,700 μs
4. **List** - ~26,500 μs (близко к времени произвольного доступа, отличие в пределах погрешности теста)
5. **MatrixArray** - ~39,000 μs

**Выводы:**
- **List** медленнее ожидаемого из-за O(n) доступа к позиции вставки
- **MatrixArray** самый медленный из-за сложной логики сдвига между строками
- Простые массивы быстрее для этих операций на больших данных

### 4. **Эффективность использования памяти**

**Процент заполнения (1M элементов):**
- **SingleArray/List** - 100% (оптимально)
- **VectorArray/MatrixArray** - 99% (очень хорошо)
- **FactorArray** - 52% (неэффективно)

**Выводы:**
- FactorArray жертвует памятью ради производительности
- VectorArray с шагом 10 показывает отличный баланс
- SingleArray оптимален по памяти, но катастрофичен по времени

### **Лучший выбор для разных сценариев:**

1. **Частые вставки в конец + чтение:**
   - **FactorArray** - лучший баланс скорости и памяти (при условии продуманного выбора значения фактора)
   - **List** - если не нужен произвольный доступ

2. **Частый произвольный доступ:**
   - **VectorArray** - оптимальное использование памяти
   - **MatrixArray** - хорошая альтернатива

3. **Минимизация памяти:**
   - **SingleArray** - только для очень маленьких datasets
   - Катастрофическая производительность на больших данных

## **Обобщенные выводы:**

- **FactorArray** в 115,000 раз быстрее SingleArray на 1M элементов
- **List** выигрывает в последовательных операциях, но проигрывает в произвольном доступе
- **MatrixArray** показал **ожидаемо низкую** производительность для операций вставки/удаления из-за:
  - Сдвига "хвоста" как в обычном массиве (O(n) операций)
  - Дополнительной сложности пересчёта индексов при переходе между строками
  - Двойного уровня косвенности при доступе к данным
### **MatrixArray целесообразно использовать когда:**
- Преобладают операции добавления в конец (push_back)
- Требуется произвольный доступ c предсказуемой закономерностью
- Важна предсказуемость памяти (фиксированный размер строк)
- Данные естественным образом ложатся на матричную структуру
### **Не рекомендуется когда:**
- Частые вставки/удаления в середину
- Критична производительность модифицирующих операций
---

*Примечание: тестирование проводилось на типе `int` с default-значениями для чистоты измерения алгоритмической сложности. Размер тестовых данных: до 1,000,000 элементов с геометрической прогрессией.*

# Задание 3. Очередь с приоритетами

- Ссылка на реализацию - [`PriorityQueue.h`](../headers/PriorityQueue.h)
  - Реализовано как список списков (использован реализованный в этом ДЗ класс List)
  - Приоритетность реализована как дискретная (для непрерывного приоритета список списков или массив массивов, как в задании, неоптимально и даже бессмысленно)
- Ссылка класс для тестирования - [`QueueTester.h`](../headers/QueueTester.h)
- При тестировании выполнялось два вида сценариев:
- ***Оценка времени добавления** элементов в очередь с такой же градацией, как и для остальных структур, и оценка ***времени извлечения** всех элементов из очереди
### полученные усредненные результаты: 
- **Enqueue**: ~1.46ms на 1M элементов
- **Dequeue**: ~0.33ms на 1.1M элементов
- **Масштабируемость**: время растет линейно O(n)
#### В этом сценарии использовалась очередь из элементов int, чтобы не искажать работу алгоритма конструированием сложных объектов
- ***Проверка корректности порядка извлечения** добавленных элементов в соответствии с требованиями приоритета в двух вариантах:
		- Добавляем сначала 60 элементов (по 20 с тремя приоритетами) в трех потоках одновременно, после добавления все 60 элементов извлекаем
		- Одновременно добавляем также 60 (по 20 с тремя приоритетами) элементов и параллельно извлекаем 80% из них, потом отдельно достаем 12 оставшихся элементов
- Ссылка на результаты тестирования - [`queue_test_output.txt`](queue_test_output.txt)
