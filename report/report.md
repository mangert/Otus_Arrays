# Анализ производительности структур данных

**Шаблонный класс для тестов**: [`class TestArrays`](../headers/TestArrays.h)
Консольный вывод результатов тестирования [`test_output.txt`](test_output.txt)

## Сводная таблица результатов (время в микросекундах)

| Операция / Структура | SingleArray | VectorArray | FactorArray | List | MatrixArray |
|---------------------|-------------|-------------|-------------|------|-------------|
| **Push Back 1M** | 2,419,888,517 | 246,824,419 | 21,008 | 185,430 | 19,406,425 |
| **Random Access** | ~0 | ~0 | ~0 | ~26,508 | ~0 |
| **Random Delete** | ~2,527 | ~2,458 | ~2,595 | ~26,452 | ~38,094 |
| **Random Insert** | ~2,556 | ~2,454 | ~2,762 | ~26,739 | ~39,947 |
| **Memory Usage** | 100% | 99% | 52% | 100% | 99% |

## Детальный анализ

### 1. **Push Back Производительность**

**Рейтинг скорости (1M элементов):**

1. **FactorArray** - 21,008 μs
2. **List** - 185,430 μs
3. **MatrixArray** - 19,406,425 μs
4. **VectorArray** - 246,824,419 μs
5. **SingleArray** - 2,419,888,517 μs (40+ минут!)

## **Выводы:**

- **FactorArray** быстрее List благодаря:
  - Меньшему количеству аллокаций памяти (O(log n) vs O(n))
  - Отсутствию накладных расходов на указатели в узлах
  - Локальности данных (cache-friendly)

- **List** медленнее из-за:
  - Постоянных аллокаций памяти для каждого элемента 
  - Плохой локальности данных (память разбросана)
*****(примечание: в данной реализации в листе хранится кроме "головы" еще и "хвост", что позволяет избежать прохода по всему списку)*****
	
- **MatrixArray** показывает средние результаты благодаря:
  - Блочному выделению памяти (целыми строками)
  - Но проигрывает FactorArray из-за избыточных копирований при resize
	
- **SingleArray** катастрофически медленный из-за O(n²) сложности

### 2. **Произвольный доступ (Random Access)**

**Рейтинг:**
1. **Все массивы** - ~0 μs (O(1) доступ)
2. **List** - ~26,508 μs (O(n) доступ)

**Выводы:**
- Массивы обеспечивают мгновенный доступ по индексу
- List требует последовательного обхода для доступа к элементу

### 3. **Вставка и удаление в середину**

**Рейтинг (среднее время):**
1. **SingleArray** - ~2,500 μs
2. **VectorArray** - ~2,450 μs  
3. **FactorArray** - ~2,700 μs
4. **List** - ~26,500 μs (близко к времени произвольного доступа, отличие в пределах погрешности теста)
5. **MatrixArray** - ~39,000 μs

**Выводы:**
- **List** медленнее ожидаемого из-за O(n) доступа к позиции вставки
- **MatrixArray** самый медленный из-за сложной логики сдвига между строками
- Простые массивы быстрее для этих операций на больших данных

### 4. **Эффективность использования памяти**

**Процент заполнения (1M элементов):**
- **SingleArray/List** - 100% (оптимально)
- **VectorArray/MatrixArray** - 99% (очень хорошо)
- **FactorArray** - 52% (неэффективно)

**Выводы:**
- FactorArray жертвует памятью ради производительности
- VectorArray с шагом 10 показывает отличный баланс
- SingleArray оптимален по памяти, но катастрофичен по времени

## Общие рекомендации

### **Лучший выбор для разных сценариев:**

1. **Частые вставки в конец + чтение:**
   - **FactorArray** - лучший баланс скорости и памяти
   - **List** - если не нужен произвольный доступ

2. **Частый произвольный доступ:**
   - **VectorArray** - оптимальное использование памяти
   - **MatrixArray** - хорошая альтернатива

3. **Минимизация памяти:**
   - **SingleArray** - только для очень маленьких datasets
   - Катастрофическая производительность на больших данных

4. **Универсальное решение:**
   - **FactorArray** с коэффициентом 1.5-2.0
   - **VectorArray** с шагом 10-100

## **Обобщенные выводы:**

- **FactorArray** в 115,000 раз быстрее SingleArray на 1M элементов
- **List** выигрывает в последовательных операциях, но проигрывает в произвольном доступе
- **Memory vs Performance** - явный tradeoff между FactorArray и VectorArray
- **MatrixArray** показал **ожидаемо низкую** производительность для операций вставки/удаления из-за:
  - Сдвига "хвоста" как в обычном массиве (O(n) операций)
  - Дополнительной сложности пересчёта индексов при переходе между строками
  - Двойного уровня косвенности при доступе к данным
**MatrixArray целесообразно использовать когда:**
- Преобладают операции добавления в конец (push_back)
- Требуется произвольный доступ с predictable паттерном
- Важна предсказуемость памяти (фиксированный размер строк)
- Данные естественным образом ложатся на матричную структуру
**Не рекомендуется когда:**
- Частые вставки/удаления в середину
- Критична производительность модифицирующих операций
- Данные имеют случайный access pattern
---

*Примечание: тестирование проводилось на типе `int` с default-значениями для чистоты измерения алгоритмической сложности. Размер тестовых данных: до 1,000,000 элементов с геометрической прогрессией.*